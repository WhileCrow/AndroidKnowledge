# 内存泄漏 #
内存泄漏：长周期对象持有短周期对象的引用，而导致短周期的对象在生命周期结束时无法被回收。

即：对象在生命周期结束时被另一个对象通过强引用持有而无法释放



如：永久性内存泄漏：非静态内部类。 如handler、runnable、asnycTask、Thread等，不管是使用匿名内部类的创建模式，还是定义一个非静态的class的模式，都会导致持有外部类使外部类无法释放。

一般类似onClickListener的用法虽然会使用匿名内部类的方式创建但不会导致内存泄漏，因为只有异步任务的匿名内部类生命周期不同才可能导致内存泄漏，同步的会被作为一个整体被GC掉。

两种特殊情况：
1. 系统监听LocationListener，系统一直持有而永久性泄漏；
2. 监听回调中有耗时操作，导致临时泄漏（见下）。）



临时性内存泄漏：静态handler有消息存在messageQueue中，由于messageQueue持有message，message持有target（handler对象），handler则会无法回收，直到消息被取出处理后，再次GC时回收。
